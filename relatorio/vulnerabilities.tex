\section{Vulnerabilidades Gerais}

No desenvolvimento de um software devemos sempre garantir que não divulgamos informação sobre como a nossa aplicação está construida. Durante o deenvolvimento do código deparamo-nos com dois possíveis problemas a tratar.\newline
\par O primeiro problema enuncia-se em seguida, "Como encerrar a aplicação com uma exceção passando uma mensagem de erro ao utilizador sem lhe revelar informação sobre o código da aplicação?". Para resolver este problema usamos a função \textit{die}, o problema é que esta para além da mensagem fornece informação sobre a linha onde ocorreu a exceção. Felizmente caso se adicione \textit{\\n} ao final da mensagem de erro emitida pelo die este omite a informação referente á linha. 
\par O segundo problema encontrado é referente á função \textit{open}, até ao ano 2000, a função open usava 2 parâmetros, um para a variável para a qual se lê e uma para o ficheiro a ler. O problema  acontece caso o utilizador use um ficheiro cujo nome comece, por exemplo, com o sinal \textit{>}, isto levará a que por exemplo caso seja dado como input o ficheiro \textit{>/etc/passwd} nós acabamos de apagar o ficheiro de passwords do Linux. Para resolver este problema usamos a versão do open com 3 variáveis, uma para guardar a informação a ler do ficheiro, uma para o tipo de leitura a realizar no ficheiro e uma para o nome do ficheiro. Acresce a este problema o facto de que caso o open use um pipe em vez de um ficheiro, ao falhar este devolve o pid do subprocesso na mensagem de erro, como queremos evitar divulgar qualquer informação sobre a aplicação usamos então a função \textit{die} para emitir o erro sem comprometer a nossa implementação tomando o código a seguinte forma: \textit{open(variável para leitura, modo de leitura, ficheiro a ler) or die ... }.\newline

\textit{Nota: As restantes questões de segurança foram abordadas e tratadas num modulo perl a parte chamado \textbf{verifiers.pm} criado para separar de forma legivel as subrotinas usadas para segurança das subrotinas do programa principal.}\newline 

Existem enúmeras vulnerabilidades a tratar para além das duas supramencionadas, nomeadamente:
\begin{enumerate}
\item Restrições sobre a memória
\item Neutralização do input durante a geração da página web
\item Improper Input Validation
\item Information Exposure
\item Out-of-Bounds Read
\item Neutralização de elementos especiais para comandos SQL (SQL Injection)
\item use after free
\item Integer Overflow or Wrapparound
\item XML Injection
\item OS Commands Injection
\item SQL Injection
\end{enumerate}

Destas vulnerabilidades a 1ª 4ª, 5ª, 6ª, 7ª e 8ª podem ser ignoradas visto que o \textit{Perl} trata da alocar as variáveis na memória libertando o programador da manutenção da mesma, para além. Assim vamos debruçar-nos sobre a vulnerabilidade 3, 9,10 e 11.


\subsection{Improper Input Validation}

Nesta secção falaremos um pouco dos inputs e da validação realizada sobre os mesmos. A validação de inputs de uma aplicação é fulcral para o bom funcionamento da mesma, nunca devemos acreditar que o utilizador usará a aplicação da melhor forma ou para fins nefastos.\newline


Assim os inputs a verificar são:  o número de telefone, o pin e o nome do ficheiro a assinar. Caso sejam fornecidos, o nome do ficheiro assinado e a data fornecida também serão verificados.\newline

\begin{itemize}
\item Nomes dos ficheiro\newline
 Para realizar a verificação tanto do nome do ficheiro de input como do ficheiro de output o processo aplicado foi o mesmo. Foram criadas 2 listas, uma white list com os caracters aceitaveis para constituirem o nome de um ficheiro (As White Lists são especialmente proveitosas visto que é mais facil indicar o que é aceitavel do que o que não é, em contrapartida limitamos um pouco os nomes possíveis para os ficheiros fornecidos) e uma black list onde removemos algumas hipóteses aceitáveis na white list mas que não podem ser dados como input do nome do ficheiro que são as flags usadas nos inputs do programa.\newline
 Convem notar que tentativas de inserção de vários comandos através da adição de \textit{;} ou de pipes com o caracter \textit{|} não funcionam pois não pertencem á lista de caracters permitidos pela white list.

\hfill\newline
\item Número de telefone\newline
 No caso do número de telefone desenvolvemos 2 regex sendo que um funciona para números internacionais e nacionais e um que funciona apenas para números nacionais, os respetivos regex apresentam-se em seguida:\newline
\begin{itemize}
	\item \textit{/\^{}\textbackslash+[0-9]\{1,3\} [0-9]\{4,14\}\$/}
	\item \textit{/\^{}\textbackslash+351 [0-9]\{9\}\$/}
\end{itemize}

\hfill\newline
\par Como a chave móvel digital para a qual a aplicação se destina normalmente está associada a números de telemovel portugueses mantivemos o segundo regex embora tenhamos deixado em comentário o segundo regex caso pretendamos estender a aplicação a números estrangeiros. A razão de escolhermos apenas números nacionais prende-se com a escolha de implementar uma segurança com granularidade mais fina visto que o número de dígitos de telemovel varia de país para país e o indicativo também.\newline
\textit{Nota: Convém notar que, nas expressões regex, são usados por vezes 2 simbolos, o \^{} no inicio do regex e o \$ no fim. Estes simbolos indicam ao perl que o regex tem de corresponder ao inicio do input e ao final deste respetivamente, isto é, caso ambos os simbolos sejam usados o perl entende que o input a testar tem de ser totalmente formado pelo regex e, caso não seja, falha a verificação.}\newline
\hfill\newline
\item PIN\newline

\par O PIN é um conjunto de 4 a 8 digitos, assim, para o testar bastou um regex simples que garantisse isso: \textit{/\^{}[0-9]\{4,8\}\$/}.

\hfill\newline
\item OTP\newline
\par O OTP é verificado como sendo um conjunto de 6 digitos. Mais uma vez o regex usado é bastante simples: \textit{/\^[0-9]\{6\}\$/}.


\hfill\newline
\item Process ID\newline

\par O ProcessID trata-se de um conjunto de 32 caracters (números e letras) que seguem um padrão especifico de formação com a seguinte caraterística: \textit{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}.\newline
\par Desta forma foi criado um padrão regex que permitisse verificar se o ProcessID recebido tinha 32 caracters sendo que este era constituido por conjuntos de 8, 4, 4, 4 e por fim 12 caracters separados por travessões: \textit{/\^[a-z0-9]\{8\}-[a-z0-9]\{4\}-[a-z0-9]\{4\}-[a-z0-9]\{4\}-[a-z0-9]\{12\}\$/}.

\hfill\newline
\item Datetime\newline

\par A Datetime trata-se de uma indicação temporal que respeita uma notação temporal reconhecida pelo servidor \textit{Rest} com o qual a aplicação comunica: \textit{YYYY-MM-DDTHH:MM:SS.SSSSSS}.
\par Para verificar se a data foi inserida respeitando a notação exigida foi criado um regex para a mesma: \textit{/\^\textbackslash d\{4\}-\textbackslash d\{2\}-\textbackslash d\{2\}T\textbackslash d\{2\}:\textbackslash d\{2\}:\textbackslash d\{2\}.\textbackslash d\{6\}\$/}. Este regex verifica se a informação é inserida, com os respetivos simbolos extra\footnote{Simbolos extra: - (separa a informação da data anual), T (separa a informação da data da informação horária), : (separa a informação horária).}, na forma ano, mês, dia, hora, minutos, segundos, nanosegundos.

\hfill\newline
\item Response\newline

\par Ao debruçarmo-nos sobre como validar a Response do servidor convêm notarmos algumas caraterísticas desta que nos podem ajudar a verificar que esta não foi alterada. 
\begin{enumerate}
	\item A resposta tem um tamanho fixo de 560 bytes independentemente do conteudo enviado para o servidor.
	\item A resposta está em base 64, ou seja só possui os seguintes caracters: [a-zA-Z+\/].
\end{enumerate}

\par Á luz desta informação podemos delinear algumas verificações para mitigar o risco de ataques be sucedidos á nossa aplicação.
\par A primeira verificação pasa por confirmar que a Response tem o número de caracters correto, assim não é possível a adição de código extra ao conteúdo da mensagem. A segunda verificação passa por verificar a existência apenas de caracters de base 64 na mesma. Por fim podiamos tentar verificar a existência de sintax SQL ou XML mas tal não será necessário uma vez que não é possível estas existirem visto que, em base 64, não se possuem os caracters: espaço, ponto e virgula, maior, menor entre outros necessários para as mesmas terem uma sintax correta.


\hfill\newline
\item Signature\newline

Mais uma vez á semelhança do parâmetro anterior a Signature tem um comprimento fixo e está em base 64. Assim, as verificações de segurança aplicadas apenas diferem na verificação do tamanho que passa de 560 para 512.


\end{itemize}


O principal foco da segurança na nossa aplicação foi aplicado ás strings. Os critérios usados na \textit{white List} e na \textit{Black List} não são muito restritivos, principalmente porque as strings são maleáveis e o utilizador pode dar o nome que quiser ao documento que pretende utilizar com a aplicação. Desta forma é necessário ter atenção a utilizadores mal intencionados que pretendam usar os critérios laços de filtragem de input para fins diferentes daquele para o qual a aplicação foi feita.\newline


\subsection{OS Injection}

O Perl é relativamente suscetivel a injeção de comandos do sistema operativo, isto pois permite utilizar pipelines com o caracter \textit{|} como input ou comandos seguidos separados pelo caracter \textit{;}. Para ambos os casos existe uma solução que apesar de restringir a liberdade do cliente de nomear os seus ficheiros recorrendo aos caracters \textit{|} e \textit{|} garante que estes ataques não ocorrem, o que do ponto de vista de uma maior qualidade na segurança da aplicação é o ideal.


\subsection{XML Injection}

Nesta subsecção vamos tratar de qualquer tentativa de injeção de código \textit{XML} na nossa aplicação. Para lidar com tentativas de injeção de código \textit{XML} através de um input foi criada uma subrotina chamada {xmlInjection} no modulo \textit{verifiers.pm}.\newline
Nesta subrotina para evitar eventuais tentativas de injeção de código \textit{XML} foi realizado um regex com a forma: \textit{/$<$[a-zA-Z]*($>$[\^{} ($<$\textbackslash/)]*$<$/[a-zA-Z]*|\textbackslash/)?$>$/} . Este regex permite realizar match entre elementos desta linguagem através de sintaxe conhecida detetando padrões como \textit{<qualquer coisa> ... </qualquer coisa>} ou \textit{<qualquer coisa/>}.

\subsection{SQL Injection}

Para tratar eventuais tentativas de injeção de código \textit{SQL} através das variáveis, foi definida uma subrotina chamada \textit{sqlInjection} que possui um array de palavras chave usadas na syntax \textit{SQL} que são comparadas através de um regex com os argumentos. Caso seja detetado num argumento uma palavra pertencente á syntax \textit{SQL} o programa emite uma mensagem de erro a avisar que detetou uma tentativa de SQL injection.

\section{Certificados Falsos}

Um problema quando se lida com certificados prende-se com a validação dos mesmos. De forma a contornar este problema recorreu-se ao módulo \textit{LWP::UserAgent}, este fornece uma opção por defeito de verificação automática do servidor e da sua legitimidade chamada \textit{verify\_hostname}. Assim são escolhidos protocolos seguros e é assegurado que nos ligamos a um servidor que possui um certificado válido.